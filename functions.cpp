
/* Подключение модулей */
#include <stdio.h>
#include "functions.h"
#include <string.h>
#include <iostream>

void words_counter(int& cnt_vow, int& cnt_cons, char* ptr) {
	// Цель: Определение количества гласных и согласных букв в строке
	// Исходные данные:
	//		&cnt_vow ? ссылка на переменную-счетчик гласных букв
	//		&cnt_cons - ссылка на переменную-счетчик согласных букв
	//		*ptr - указатель на начало целевой строки
	// Результат: Соответствующим переменным-счетчикам по ссылкам присвоены значения,
	// соответствующие количеству гласных и согласных букв в строке
	// Вызываемые модули: <string.h>
	/* Описание алгоритма :
	* 1) Инициализируется строка vowels, содержащая все гласные буквы русского алфавита
	* 2) С помощью указателя *ptr выполняется обход символов целевой строки в цикле
	* 3) Для каждой итерации проверяется наличие вхождений очередного символа строки в строке vowels:
	*	- если очередной символ содержится в vowels, счетчик гласных cnt_vow увеличивается на 1;
	*	- иначе выполняется проверка: является ли текущий символ символом русского алфавита
	*	В кодировке KOI8-R строчные и заглавные символы русского алфавита распологаются подряд,
	*	но не в алфавитном порядке, и имеют кодовые номера, соответствующие числам от 192 до 255 включительно.
	*	Использование типа char позволяет получить корректный кодовый номер символа, учитывая что кодовые значения символов
	*	от 128 до 255 соответствуют целым числам от 0 до -128 включительно,	если строка закодирована в KOI8-R
	*	и работа программы настроена на нее.
	*	- если целочисленное значение очередного символа принадлежит отрезку [-128, 0],
	*	счетчик согласных cnt_cons увеличивается на 1.
	// Дата: 2022 / 02 / 06 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**************************************************************************************/
	const char* vowels = "аеёиоуыэюяАЕИОУЫЭЮЯ"; // Строка гласных букв русского алфавита
	while (*ptr != '\0') { // Пока не достигнут конец строки
		if (strchr(vowels, (int)*ptr) != NULL) { // Проверка наличия вхождений символа в строке гласных
			cnt_vow++; 
		}
		/* Проверка соответствия целочисленного значения символа кодам букв русского алфавита в кодировке KOI8-R */
		else if (-128 <= *ptr && *ptr <= 0) {
			cnt_cons++;
		}
		ptr++; // Продвижение по строке
	}
}
void FileToBuffer(char* path, char* file_buffer, char* str_buffer) {
	// Цель: Считывание содержимого файла в буферную строку
	// Исходные данные:
	//		path - указатель на строку для ввода пути к исходному файлу
	//		file_buffer - указатель на строку-буфер для накопления содержимого файла
	//		str_buffer - указатель на строку-буфер для построчного обхода файла
	// Результат: Содержимое файла накоплено в буферной строке file_buffer
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 1) Объявляется указатель "data" на целевой файл и инициализируется значением NULL
	* 2) Выводится запрос на ввод пути и открытие файла, с проверкой успешного выполнения операции
	* 3) Выполняется проверка не равенство нулю указателя "data"
	* 4) Выполняется построчное считывание файла в строку str_buffer и ей конкатенация с file_buffer
	* 5) Выполняется выполняется закрытие файла, с проверкой успешного выполнения операции
	// Дата: 2022 / 02 / 06 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**********************************************************************************************/
	/* Открытие файла */
	FILE* data = NULL;
	do {
		printf("\n* Для начала работы введите корректный путь к файлу.txt (в кодировке KOI8-R): *\n ");
		scanf_s("%s\0", path, STRLEN);
	} while (fopen_s(&data, path, "r") != 0); //Запрашиваем корректный путь пока код ошибки не равен 0

	/* Если файл не пустой продолжаем работу с его содержимым */
	if (data != 0) {
		*file_buffer = '\0';
		while ((fscanf_s(data, "%[^\n]", str_buffer, STRLEN)) != EOF) { // Считываем содержимое файла построчно
			snprintf(file_buffer, FULLEN, "%s %s\n", file_buffer, str_buffer); // конкатенация file_buffer и str_buffer
			fgetc(data); // Считываем символ '\n' для продвижения по файлу
		}
		/* Закрытие файла */
		if (fclose(data) != 0) {
			printf("Ошибка закрытия файла\n");
		}
	}
}

void DefineOutPath(char* path, char* out_path) {
	// Цель: Определить путь выходного файла и сохранить в соответствующей строке
	// Исходные данные:
	//		path - указатель на строку, содержащую путь к исходному файлу
	//		out_path - указатель на строку, содержащую путь к результирующему файлу
	// Результат: Путь к результирующему файлу сохранен в строке, на которую указывает out_path
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 1) В строку out_path копируется содержимое строки path без расширения
	* 2) В строку out_path добавляется маркер "_result.txt"
	// Дата: 2022 / 02 / 06 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**********************************************************************************************/
	strncpy_s(out_path, STRLEN, path, strlen(path) - 4);
	strcat_s(out_path, STRLEN, "_result.txt");
}

void PrintBufferToFile(char buf[], char* path) {
	// Цель: Вывод содержимого строки-буфера в файл
	// Исходные данные:
	//		buf - целевая строка-буфер
	//		path - указатель на строку, содержащую путь для результирующего файла
	// Результат: Содержимое строки-буфера выведено в файл
	// Вызываемые модули: нет
	/* Описание алгоритма :
	* 1) Объявляется указатель "data" на целевой файл и инициализируется значением NULL
	* 2) Выполняется открытие/создание файла, с проверкой успешного выполнения операции
	* 3) Выполняется проверка не равенство нулю указателя "data"
	* 4) Выполняется вывод содержимого строки-буфера в целевой файл с помощью инструкции "fprintf()"
	* 5) Выполняется выполняется закрытие файла, с проверкой успешного выполнения операции
	// Дата: 2022 / 02 / 06 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**********************************************************************************************/
	
	FILE* data = NULL;
	if (fopen_s(&data, path, "w") != 0) {//код ошибки не равен 0
		printf("Ошибка открытия файла!\n");
		system("pause");
	}
	if (data != 0) {
		fprintf(data, buf);
		if (fclose(data) != 0) {
			printf("Ошибка закрытия файла\n");
		}
	}
}

void ResultBufferAssembly(char* result_buffer, const char* logo, char* path, char* file_buffer, \
	int cnt_vowels, int cnt_consonants) {
	// Цель: "Сборка" данных в буферную строку для последующего вывода
	// Исходные данные:
	//		result_buffer - указатель на результирующую строку
	//		logo - указатель на строку, содержащую логотип программы
	//		path - Указатель на строку, содержащую путь к исходному файлу
	//		file_buffer - указатель на строку, содержащую содержимое файла
	//		cnt_vowels - целочисленная переменная, содержащая количество гласных в исходном файле
	//		cnt_сщтыщтфтеы - целочисленная переменная, содержащая количество согласных в исходном файле
	// Результат: Строка result_buffer содержит результат исполнения программы согласно условию задачи
	// Вызываемые модули: <string.h>
	/* Описание алгоритма :
	* 1) В результирующую строку копируется логотип программы
	* 2) Выполняется форматная конкатенация результирующе строки и заголовка содержания файла,
	* содержащего путь к исходному файлу
	* 3) Выполняется копирование содержимого файла в результирующую строку
	* 4) Выполняется форматная конкатенация результирующего файла и строки, содержащей информацию 
	* о вычислениях согласно условия задачи
	// Дата: 2022 / 02 / 06 Версия 1.01
	// Автор: Студент НГТУ ИРИТ, Халеев А. А. гр. 21-ИВТз
	// Исправления: нет
	/**********************************************************************************************/
	strcpy_s(result_buffer, FULLEN, logo);
	snprintf(result_buffer, FULLEN, "%s\n * Содержание файла %s: *\n\n", result_buffer, path);
	strcat_s(result_buffer, FULLEN, file_buffer);
	snprintf(result_buffer, FULLEN, "%s\n * Результаты подсчета: *\n\n\
 Количество гласных букв в документе равно : % d\n\
 Количество согласных букв в документе равно: %d\n", result_buffer, cnt_vowels, cnt_consonants);
}

/* Функция вызова исключения связанного с выделением памяти для передачи в set_new_handler() */
void __cdecl new_error() {
	throw std::bad_alloc();
	return;
}
